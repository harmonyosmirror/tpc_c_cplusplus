From 4ce6a4cb426c72cb8ca63c8cd118b44d2c7947c8 Mon Sep 17 00:00:00 2001
From: xujian <xujian@demo.com>
Date: Sun, 8 Dec 2024 09:59:33 +0800
Subject: [PATCH] =?UTF-8?q?=E4=BF=AE=E6=94=B9secret-password=E7=B3=BB?=
 =?UTF-8?q?=E5=88=97=E6=8E=A5=E5=8F=A3?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 egg/egg-secure-memory.h         |    8 +
 libsecret/meson.build           |   30 +-
 libsecret/ohos-huks-crypto.cpp  |  218 ++++
 libsecret/ohos-huks-crypto.h    |   60 ++
 libsecret/ohos-secret-store.cpp |  243 +++++
 libsecret/ohos-secret-store.h   |  100 ++
 libsecret/secret-password.cpp   | 1688 +++++++++++++++++++++++++++++++
 libsecret/test-ohos-password.c  |  596 +++++++++++
 meson.build                     |    2 +-
 meson_options.txt               |    1 +
 tool/secret-tool.c              |   13 +
 11 files changed, 2956 insertions(+), 3 deletions(-)
 create mode 100644 libsecret/ohos-huks-crypto.cpp
 create mode 100644 libsecret/ohos-huks-crypto.h
 create mode 100644 libsecret/ohos-secret-store.cpp
 create mode 100644 libsecret/ohos-secret-store.h
 create mode 100644 libsecret/secret-password.cpp
 create mode 100644 libsecret/test-ohos-password.c

diff --git a/egg/egg-secure-memory.h b/egg/egg-secure-memory.h
index 660bc6f..7c320ef 100644
--- a/egg/egg-secure-memory.h
+++ b/egg/egg-secure-memory.h
@@ -106,10 +106,18 @@ char*  egg_secure_strdup_full  (const char *tag, const char *str, int options);
 
 char*  egg_secure_strndup_full (const char *tag, const char *str, size_t length, int options);
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 void   egg_secure_strclear     (char *str);
 
 void   egg_secure_strfree      (char *str);
 
+#ifdef __cplusplus
+}
+#endif
+
 typedef struct {
 	const char *tag;
 	size_t request_length;
diff --git a/libsecret/meson.build b/libsecret/meson.build
index 85ad68f..e8c8cc2 100644
--- a/libsecret/meson.build
+++ b/libsecret/meson.build
@@ -7,7 +7,6 @@ libsecret_sources = [
   'secret-collection.c',
   'secret-item.c',
   'secret-methods.c',
-  'secret-password.c',
   'secret-prompt.c',
   'secret-retrievable.c',
   'secret-schema.c',
@@ -25,6 +24,8 @@ libsecret_headers = [
   'secret-backend.h',
   'secret-collection.h',
   'secret-item.h',
+  'ohos-huks-crypto.h',
+  'ohos-secret-store.h',
   'secret-password.h',
   'secret-paths.h',
   'secret-prompt.h',
@@ -36,6 +37,18 @@ libsecret_headers = [
   'secret-value.h',
 ]
 
+if get_option('is_ohos')
+  libsecret_sources += [
+    'ohos-huks-crypto.cpp',
+    'ohos-secret-store.cpp',
+    'secret-password.cpp',
+  ]
+else
+  libsecret_sources += [
+    'secret-password.c',
+  ]
+endif
+
 if with_crypto
   libsecret_sources += [
     'secret-file-backend.c',
@@ -115,7 +128,11 @@ if get_option('introspection')
     'secret-item.c',
     'secret-item.h',
     'secret-methods.c',
-    'secret-password.c',
+    'ohos-secret-store.cpp',
+    'ohos-secret-store.h',
+    'ohos-huks-crypto.cpp',
+    'ohos-huks-crypto.h',
+    'secret-password.cpp',
     'secret-password.h',
     'secret-paths.c',
     'secret-paths.h',
@@ -230,6 +247,15 @@ test_names = [
   'test-item',
   'test-collection',
 ]
+ohos_test_names = [
+  'test-attributes',
+  'test-value',
+  'test-ohos-password',
+]
+
+if get_option('is_ohos')
+  test_names = ohos_test_names
+endif
 
 if with_crypto
   test_names += [
diff --git a/libsecret/ohos-secret-store.cpp b/libsecret/ohos-secret-store.cpp
new file mode 100644
index 0000000..15ba03c
--- /dev/null
+++ b/libsecret/ohos-secret-store.cpp
@@ -0,0 +1,243 @@
+#include "ohos-secret-store.h"
+#include "ohos-huks-crypto.h"
+
+#include <hilog/log.h>
+
+
+static const int is_debug = true;
+static const std::string COLUMN_VALUE = "_VALUE";
+static const int COLUMN_VALUE_INDEX = 0;
+
+const std::string HUKS_CRYPTO_ALIAS = "chrome_huks_os_crypt_password_v1";
+
+
+static std::string replace_all(std::string &str, std::string oldStr, std::string newStr){
+    std::string::size_type pos = str.find(oldStr);
+    while(pos != std::string::npos){
+        str.replace(pos, oldStr.size(), newStr);
+        pos = str.find(oldStr);
+    }
+    return str;
+}
+
+static std::string make_table_name(const SecretSchema *schema) {
+    std::string table_name(schema->name);
+    table_name = replace_all(table_name, ".", "_");
+
+    return "t_" + table_name;
+}
+
+static std::string make_field_name(const std::string &field) {
+    std::string new_field = field;
+    new_field = replace_all(new_field, ":", "_");
+    return "_" + new_field;
+}
+
+static std::string make_create_table_sql(const SecretSchema *schema) {
+    // 建表初始化
+    std::vector<std::string> columns;
+    for (int i = 0; i < G_N_ELEMENTS (schema->attributes); i++) {
+        if (!schema->attributes[i].name) {
+            break;
+        }
+        if (!g_strcmp0("NULL", schema->attributes[i].name)) {
+            continue;
+        }
+        columns.push_back(schema->attributes[i].name);
+    }
+
+    std::string create_table_sql = "CREATE TABLE IF NOT EXISTS " + make_table_name(schema) +
+                                        " ( " + COLUMN_VALUE + " TEXT NOT NULL, _collection TEXT";
+    for (auto it = columns.begin();it != columns.end(); it++) {
+        std::string one_column = ", " + make_field_name(*it) + " TEXT";
+        create_table_sql += one_column;
+    }
+    if (is_debug) {
+        OH_LOG_INFO(LOG_APP, "secret-store create_table debug_msg: %{public}s", create_table_sql.c_str());
+    }
+    return create_table_sql + ")";
+}
+
+// 封装function进c风格调用
+class FunctionUnion{
+public:
+    FunctionUnion(std::function<void(gpointer, gpointer, gpointer)> f, GError **e):func(f), error(e) {}
+
+    static void call_functional(gpointer node_key, gpointer node_value, gpointer user_data) {
+        FunctionUnion *obj = (FunctionUnion *)user_data;
+        obj->func(node_key, node_value, obj->error);
+    }
+    
+private:
+    std::function<void(gpointer, gpointer, gpointer)> func;
+    GError **error;
+};
+
+static std::shared_ptr<OH_Predicates> new_filter(const std::string &table_name, GHashTable *attributes, GError **error) {
+    OH_Predicates *predicates_obj = OH_Rdb_CreatePredicates(table_name.c_str());
+    g_set_error_return_val_if_fail(predicates_obj, nullptr, "ohos_rdb:OH_Rdb_CreatePredicates call error");
+    auto predicates = std::shared_ptr<OH_Predicates>(predicates_obj, [](OH_Predicates *obj) { obj->destroy(obj); });
+
+    std::string debug_msg;
+    // 过滤条件拼接
+    std::function<void(gpointer, gpointer, gpointer)> for_each_func = [&predicates, &debug_msg](gpointer node_key, gpointer node_value, gpointer user_data) {
+        if (!g_strcmp0("NULL", (const char*)node_key)) {
+            return ;
+        }
+        GError **error = (GError **)user_data;
+        OH_VObject *value_obj = OH_Rdb_CreateValueObject();
+        g_set_error_return_if_fail(value_obj, "ohos_rdb:OH_Rdb_CreateValueObject call error");
+        auto vobject = std::shared_ptr<OH_VObject>(value_obj, [](OH_VObject *obj) { obj->destroy(obj); });
+
+        debug_msg += "|" + std::string((const char*)node_key) + " " + std::string((const char*)node_value);
+        int errcode = vobject->putText(vobject.get(), (const char*)node_value);
+        g_set_error_return_if_fail(errcode == RDB_OK_CODE, "ohos_rdb:OH_Rdb_CreateValueObject call erro");
+        predicates->equalTo(predicates.get(), make_field_name((const char*)node_key).c_str(), vobject.get());
+    };
+    if (is_debug) {
+        OH_LOG_INFO(LOG_APP, "secret-store filter debug_msg: %{public}s", debug_msg.c_str());
+    }
+
+    FunctionUnion function_union(for_each_func, error);
+    g_hash_table_foreach(attributes, FunctionUnion::call_functional, &function_union);
+    g_return_val_if_fail(*error == NULL, nullptr);
+
+    return predicates;
+}
+
+static std::shared_ptr<OH_VBucket> new_insert_bucket(GHashTable *attributes, GError **error) {
+    OH_VBucket *bucket_obj = OH_Rdb_CreateValuesBucket();
+    g_set_error_return_val_if_fail(bucket_obj, nullptr, "ohos_rdb:OH_Rdb_CreateValuesBucket call error");
+    auto bucket = std::shared_ptr<OH_VBucket>(bucket_obj, [](OH_VBucket *obj) { obj->destroy(obj); });
+
+    std::function<void(gpointer, gpointer, gpointer)> for_each_func = [&bucket](gpointer node_key, gpointer node_value, gpointer user_data) {
+        if (!g_strcmp0("NULL", (const char*)node_key)) {
+            return ;
+        }
+        GError **error = (GError **)user_data;
+        int errcode = bucket->putText(bucket.get(), make_field_name((const char*)node_key).c_str(), (const char*)node_value);
+        g_set_error_return_if_fail(errcode == RDB_OK_CODE, "ohos_rdb:bucket:putText call error");
+    };
+    FunctionUnion function_union(for_each_func, error);
+    g_hash_table_foreach(attributes, FunctionUnion::call_functional, &function_union);
+    g_return_val_if_fail(*error == NULL, nullptr);
+
+    return bucket;
+}
+    
+static void rdb_row_get_text(OH_Cursor *cursor, int index, std::function<void(const char *data, size_t len)> callback, GError **error) {
+    int err_code = 0;
+    size_t valuelen = 0;
+    err_code = cursor->getSize(cursor, index, &valuelen);
+    g_set_error_return_if_fail(err_code == RDB_OK_CODE, "ohos_rdb:cursor->getSize call error");
+    
+    // 数值长度为0的情况回调
+    if (valuelen == 0) {
+        callback("", 0);
+        return ;
+    }
+    
+    uint8_t *value = (uint8_t *)new char[valuelen + 1];
+    err_code = cursor->getBlob(cursor, index, value, valuelen + 1);
+    g_set_error_return_if_fail(err_code == RDB_OK_CODE, "ohos_rdb:cursor->getText call error");
+
+    // 正常数据回调
+    callback((const char*)value, (size_t)valuelen);
+    delete[] value;
+}
+
+std::unique_ptr<OH_Rdb_Config> RdbKvStore::default_config(const SecretSchema *schema) {
+    std::unique_ptr<OH_Rdb_Config> config = std::make_unique<OH_Rdb_Config>();
+    // 该路径为应用沙箱路径
+    config->dataBaseDir = "/data/storage/el2/base/files/libsecret-v1/";
+    config->storeName = schema->name;
+    config->bundleName = nullptr;
+    config->moduleName = nullptr;
+    // 数据库是否加密
+    config->isEncrypt = false;
+    config->securityLevel = OH_Rdb_SecurityLevel::S1;
+    config->selfSize = sizeof(OH_Rdb_Config);
+
+    return config;
+}
+
+void RdbKvStore::put_record(const SecretSchema *schema, GHashTable *attributes, const char *password, GError **error) {
+    ensure_rdb_exist(schema, error);
+    g_return_if_fail(*error == NULL);
+
+    auto bucket = new_insert_bucket(attributes, error);
+    g_return_if_fail(*error == NULL && bucket != nullptr);
+
+    OhosHuksCrypto &crypto = OhosHuksCrypto::GetInstance();
+    std::string encrypassword;
+    bool crypto_success = crypto.EncryptKey(HUKS_CRYPTO_ALIAS, password, &encrypassword);
+    g_set_error_return_if_fail(crypto_success == true, "ohos_crypto:EncryptKey call error");
+
+    int errcode = bucket->putBlob(bucket.get(), COLUMN_VALUE.c_str(), (const uint8_t *)encrypassword.c_str(), 
+        (uint32_t)encrypassword.length());
+    g_set_error_return_if_fail(errcode == RDB_OK_CODE, "ohos_rdb:bucket:putText call error");
+
+    int rowId = OH_Rdb_Insert(this->store_.get(), make_table_name(schema).c_str(), bucket.get());
+    g_set_error_return_if_fail(rowId != RDB_ERROR_CODE, "ohos_rdb:OH_Rdb_Insert call error");
+}
+
+std::string RdbKvStore::get_record(const SecretSchema *schema, GHashTable *attributes, GError **error) {
+    ensure_rdb_exist(schema, error);
+    g_return_val_if_fail(*error == NULL, "");
+
+    auto predicates = new_filter(make_table_name(schema), attributes, error);
+    g_return_val_if_fail(*error == NULL && predicates != nullptr, "");
+
+    const char *columnNames[] = {COLUMN_VALUE.c_str()};
+    int len = sizeof(columnNames) / sizeof(columnNames[0]);
+    OH_Cursor *cursor_obj = OH_Rdb_Query(this->store_.get(), predicates.get(), columnNames, len);
+    g_set_error_return_val_if_fail(cursor_obj, "", "ohos_rdb:OH_Rdb_Query call error");
+    auto cursor = std::shared_ptr<OH_Cursor>(cursor_obj, [](OH_Cursor *obj) { obj->destroy(obj); });
+
+    // 结果为空，返回，否则取第一个
+    int err_code = cursor->goToNextRow(cursor.get());
+    g_return_val_if_fail(err_code == OH_Rdb_ErrCode::RDB_OK, "");
+
+    std::string value;
+    rdb_row_get_text(cursor.get(), COLUMN_VALUE_INDEX, [&value](const char *data, size_t len) { value = std::string(data, len); }, error);
+    g_set_error_return_val_if_fail(*error == NULL, "", "ohos_rdb:rdb_row_get_text call error");
+
+    std::string ans;
+    OhosHuksCrypto &crypto = OhosHuksCrypto::GetInstance();
+    bool crypto_success = crypto.DecryptKey(HUKS_CRYPTO_ALIAS, value, &ans);
+    g_set_error_return_val_if_fail(crypto_success == true, "", "ohos_crypto:DecryptKey call error");
+
+    return ans;
+}
+
+bool RdbKvStore::remove(const SecretSchema *schema, GHashTable *attributes, GError **error) {
+    ensure_rdb_exist(schema, error);
+    g_return_val_if_fail(*error == NULL, false);
+
+    auto predicates = new_filter(make_table_name(schema), attributes, error);
+    g_return_val_if_fail(*error == NULL && predicates != nullptr, false);
+    
+    int deleteRows = OH_Rdb_Delete(this->store_.get(), predicates.get());
+    g_set_error_return_val_if_fail(deleteRows >= 0, false, "ohos_rdb:OH_Rdb_Delete call error");
+
+    return deleteRows > 0;
+}
+
+std::shared_ptr<OH_Rdb_Store> RdbKvStore::ensure_rdb_exist(const SecretSchema *schema, GError **error) {
+    if (this->store_ != nullptr) {
+        return this->store_;
+    }
+
+    int err_code = 0;
+    OH_Rdb_Store *store_obj = OH_Rdb_GetOrOpen(config_.get(), &err_code);
+    g_set_error_return_val_if_fail (err_code == RDB_OK_CODE && store_obj, NULL, "ohos_rdb:OH_Rdb_GetOrOpen call error");
+
+    // store_生命周期随类释放
+    this->store_ = std::shared_ptr<OH_Rdb_Store>(store_obj, [](OH_Rdb_Store *del_store){
+        OH_Rdb_CloseStore(del_store);
+    });
+    err_code = OH_Rdb_Execute(this->store_.get(), make_create_table_sql(schema).c_str());
+    g_set_error_return_val_if_fail (err_code == RDB_OK_CODE, NULL, "ohos_rdb:OH_Rdb_Execute call create table error");
+
+    return this->store_;
+}
diff --git a/libsecret/ohos-secret-store.h b/libsecret/ohos-secret-store.h
new file mode 100644
index 0000000..06e3d93
--- /dev/null
+++ b/libsecret/ohos-secret-store.h
@@ -0,0 +1,100 @@
+#if !defined (__OHOS__)
+#error "Only Use By OHOS Platform!!!"
+#endif
+
+#ifndef SECRET_STORE_H
+#define SECRET_STORE_H
+
+#define __SECRET_INSIDE_HEADER__
+
+#include "secret-schema.h"
+#include "secret-value.h"
+
+#include <database/rdb/oh_cursor.h>
+#include <database/rdb/oh_predicates.h>
+#include <database/rdb/oh_value_object.h>
+#include <database/rdb/oh_values_bucket.h>
+#include <database/rdb/relational_store.h>
+#include <database/rdb/relational_store_error_code.h>
+
+#include "glib.h"
+
+#include <string>
+#include <memory>
+#include <functional>
+#include <vector>
+
+
+#define g_set_error_return_val_if_fail(expr, val, log_msg)                                                             \
+    G_STMT_START {                                                                                                     \
+        if (G_LIKELY(expr)) {                                                                                          \
+        } else {                                                                                                       \
+            g_set_error(error, SECRET_ERROR, RDB_ERROR, log_msg);                                                      \
+            g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr);                                                  \
+            return (val);                                                                                              \
+        }                                                                                                              \
+    }                                                                                                                  \
+    G_STMT_END
+
+#define g_set_error_return_if_fail(expr, log_msg)                                                                      \
+    G_STMT_START {                                                                                                     \
+        if (G_LIKELY(expr)) {                                                                                          \
+        } else {                                                                                                       \
+            g_set_error(error, SECRET_ERROR, RDB_ERROR, log_msg);                                                      \
+            g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr);                                                  \
+            return ;                                                                                                   \
+        }                                                                                                              \
+    }                                                                                                                  \
+    G_STMT_END
+
+#define g_return_val_if_fail(expr, val)                                                                                \
+    G_STMT_START {                                                                                                     \
+        if (G_LIKELY(expr)) {                                                                                          \
+        } else {                                                                                                       \
+            return (val);                                                                                              \
+        }                                                                                                              \
+    }                                                                                                                  \
+    G_STMT_END
+
+#define g_return_if_fail(expr)                                                                                         \
+    G_STMT_START {                                                                                                     \
+        if (G_LIKELY(expr)) {                                                                                          \
+        } else {                                                                                                       \
+            return ;                                                                                                   \
+        }                                                                                                              \
+    }                                                                                                                  \
+    G_STMT_END
+
+// todo: 临时
+const int RDB_ERROR = 1;
+
+static const int RDB_OK_CODE = 0;
+static const int RDB_ERROR_CODE = -1;
+
+class RdbKvStore{
+
+public:
+    RdbKvStore(std::unique_ptr<OH_Rdb_Config> config):config_(std::move(config)) {    }
+    
+    ~RdbKvStore() {
+		store_ = nullptr;
+	}
+
+    static std::unique_ptr<OH_Rdb_Config> default_config(const SecretSchema *schema);
+
+    void put_record(const SecretSchema *schema, GHashTable *attributes, const char *password, GError **error);
+
+    std::string get_record(const SecretSchema *schema, GHashTable *attributes, GError **error);
+
+    bool remove(const SecretSchema *schema, GHashTable *attributes, GError **error);
+
+private:
+
+	std::shared_ptr<OH_Rdb_Store> ensure_rdb_exist(const SecretSchema *schema, GError **error);
+
+    std::shared_ptr<OH_Rdb_Store> store_ = nullptr;
+    std::unique_ptr<OH_Rdb_Config> config_ = nullptr;
+};
+
+
+#endif
diff --git a/libsecret/test-ohos-password.c b/libsecret/test-ohos-password.c
new file mode 100644
index 0000000..3fc0358
--- /dev/null
+++ b/libsecret/test-ohos-password.c
@@ -0,0 +1,596 @@
+/* libsecret - GLib wrapper for Secret Service
+ *
+ * Copyright 2012 Red Hat Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; either version 2 of the licence or (at
+ * your option) any later version.
+ *
+ * See the included COPYING file for more information.
+ *
+ * Author: Stef Walter <stefw@gnome.org>
+ */
+
+#include "config.h"
+
+#undef G_DISABLE_ASSERT
+
+#include "secret-password.h"
+#include "secret-paths.h"
+#include "secret-private.h"
+
+#include "mock-service.h"
+
+#include "egg/egg-testing.h"
+
+#include <glib.h>
+
+#include <errno.h>
+#include <stdlib.h>
+
+static const SecretSchema MOCK_SCHEMA = {
+	"org.mock.Schema",
+	SECRET_SCHEMA_NONE,
+	{
+		{ "number", SECRET_SCHEMA_ATTRIBUTE_INTEGER },
+		{ "string", SECRET_SCHEMA_ATTRIBUTE_STRING },
+		{ "even", SECRET_SCHEMA_ATTRIBUTE_BOOLEAN },
+	}
+};
+
+static const SecretSchema NO_NAME_SCHEMA = {
+	"unused.Schema.Name",
+	SECRET_SCHEMA_DONT_MATCH_NAME,
+	{
+		{ "number", SECRET_SCHEMA_ATTRIBUTE_INTEGER },
+		{ "string", SECRET_SCHEMA_ATTRIBUTE_STRING },
+	}
+};
+
+typedef struct {
+	GPid pid;
+} Test;
+
+static void
+setup (Test *test,
+       gconstpointer data)
+{
+	gboolean ret;
+	char *collection_path = NULL;
+	GError *error = NULL;
+	
+	collection_path = "/org/freedesktop/secrets/english";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "111", NULL, &error,
+										"number", 1 ,
+										"string", "one", 
+										"even", FALSE, 
+										NULL);
+	g_assert_no_error (error);
+	
+	collection_path = "/org/freedesktop/secrets/english";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "222", NULL, &error,
+										"number", 2,
+										"string", "two", 
+										"even", TRUE, 
+										"xdg:schema", "org.mock.Schema",
+										NULL);
+	g_assert_no_error (error);
+
+	collection_path = "/org/freedesktop/secrets/english";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "333", NULL, &error,
+										"number", 3,
+										"string", "three", 
+										"even", FALSE, 
+										"xdg:schema", "org.mock.Schema",
+										NULL);
+	g_assert_no_error (error);
+
+	collection_path = "/org/freedesktop/secrets/spanish";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "111", NULL, &error,
+										"number", 1,
+										"string", "uno", 
+										"even", FALSE, 
+										"xdg:schema", "org.mock.Schema",
+										NULL);
+	g_assert_no_error (error);
+
+	collection_path = "/org/freedesktop/secrets/spanish";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "222", NULL, &error,
+										"number", 2,
+										"string", "dos", 
+										"even", TRUE, 
+										"xdg:schema", "org.mock.Schema",
+										NULL);
+	g_assert_no_error (error);
+
+	collection_path = "/org/freedesktop/secrets/spanish";
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+										"Label here", "333", NULL, &error,
+										"number", 3,
+										"string", "three", 
+										"even", FALSE, 
+										"xdg:schema", "org.mock.Schema",
+										NULL);
+	g_assert_no_error (error);
+}
+
+static void
+teardown (Test *test,
+          gconstpointer unused)
+{
+
+}
+
+static void
+on_complete_get_result (GObject *source,
+                        GAsyncResult *result,
+                        gpointer user_data)
+{
+	GAsyncResult **ret = user_data;
+	g_assert_nonnull (ret);
+	g_assert_null (*ret);
+	*ret = g_object_ref (result);
+	egg_test_wait_stop ();
+}
+
+static void
+test_lookup_sync (Test *test,
+                  gconstpointer used)
+{
+	gchar *password;
+	GError *error = NULL;
+
+	password = secret_password_lookup_nonpageable_sync (&MOCK_SCHEMA, NULL, &error,
+	                                                    "even", FALSE,
+	                                                    "string", "one",
+	                                                    "number", 1,
+	                                                    NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (password, ==, "111");
+
+	secret_password_free (password);
+}
+
+static void
+test_lookup_async (Test *test,
+                   gconstpointer used)
+{
+	GAsyncResult *result = NULL;
+	GError *error = NULL;
+	gchar *password;
+
+	secret_password_lookup (&MOCK_SCHEMA, NULL, on_complete_get_result, &result,
+	                        "even", FALSE,
+	                        "string", "one",
+	                        "number", 1,
+	                        NULL);
+	g_assert_null (result);
+
+	egg_test_wait ();
+
+	password = secret_password_lookup_nonpageable_finish (result, &error);
+	g_assert_no_error (error);
+	g_object_unref (result);
+
+	g_assert_cmpstr (password, ==, "111");
+	secret_password_free (password);
+}
+
+static void
+test_lookup_no_name (Test *test,
+                     gconstpointer used)
+{
+	GError *error = NULL;
+	gchar *password;
+
+	/* should return null, because nothing with mock schema and 3 */
+	password = secret_password_lookup_sync (&NO_NAME_SCHEMA, NULL, &error,
+											"number", 3,
+											NULL);
+	g_assert_no_error (error);
+	g_assert_null (password);
+
+	/* should return an item, because we have a prime schema with 3, and flags not to match name */
+	password = secret_password_lookup_sync (&MOCK_SCHEMA, NULL, &error,
+											"number", 3,
+											NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (password, ==, "333");
+
+	secret_password_free (password);
+}
+
+static void
+test_store_sync (Test *test,
+                  gconstpointer used)
+{
+	const gchar *collection_path = "/org/freedesktop/secrets/collection/english";
+	GError *error = NULL;
+	gchar *password;
+	gboolean ret;
+
+	ret = secret_password_store_sync (&MOCK_SCHEMA, collection_path,
+	                                  "Label here", "the password", NULL, &error,
+	                                  "even", TRUE,
+	                                  "string", "twelve",
+	                                  "number", 12,
+	                                  NULL);
+
+	g_assert_no_error (error);
+	g_assert_true (ret);
+
+	password = secret_password_lookup_nonpageable_sync (&MOCK_SCHEMA, NULL, &error,
+	                                                    "string", "twelve",
+	                                                    NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (password, ==, "the password");
+
+	secret_password_free (password);
+}
+
+static void
+test_store_async (Test *test,
+                  gconstpointer used)
+{
+	const gchar *collection_path = "/org/freedesktop/secrets/collection/english";
+	GAsyncResult *result = NULL;
+	GError *error = NULL;
+	gchar *password;
+	gboolean ret;
+
+	secret_password_store (&MOCK_SCHEMA, collection_path, "Label here",
+	                       "the password", NULL, on_complete_get_result, &result,
+	                       "even", TRUE,
+	                       "string", "twelve",
+	                       "number", 12,
+	                       NULL);
+	g_assert_null (result);
+
+	egg_test_wait ();
+
+	ret = secret_password_store_finish (result, &error);
+	g_assert_no_error (error);
+	g_assert_true (ret);
+	g_object_unref (result);
+
+	password = secret_password_lookup_nonpageable_sync (&MOCK_SCHEMA, NULL, &error,
+	                                                    "string", "twelve",
+	                                                    NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (password, ==, "the password");
+
+	secret_password_free (password);
+}
+
+static void
+test_store_unlock (Test *test,
+                   gconstpointer unused)
+{
+	const gchar *collection_path = "/org/freedesktop/secrets/collection/english";
+	GAsyncResult *result = NULL;
+	SecretCollection *collection;
+	SecretService *service;
+	GError *error = NULL;
+	gchar *password;
+	gboolean ret;
+	GList *objects;
+	gint count;
+
+	service = secret_service_get_sync (SECRET_SERVICE_NONE, NULL, &error);
+	g_assert_no_error (error);
+
+	/* Check collection state */
+	collection = secret_collection_new_for_dbus_path_sync (service, collection_path,
+	                                                       SECRET_COLLECTION_NONE, NULL, &error);
+	g_assert_no_error (error);
+	g_assert_false (secret_collection_get_locked (collection));
+
+	/* Lock it, use async, so collection properties update */
+	objects = g_list_append (NULL, collection);
+	secret_service_lock (service, objects, NULL, on_complete_get_result, &result);
+	egg_test_wait ();
+	count = secret_service_lock_finish (service, result, NULL, &error);
+	g_assert_cmpint (count, ==, 1);
+	g_clear_object (&result);
+	g_list_free (objects);
+
+	/* Check collection state */
+	g_assert_true (secret_collection_get_locked (collection));
+
+	/* Store the password, use async so collection properties update */
+	secret_password_store (&MOCK_SCHEMA, collection_path, "Label here",
+	                       "the password", NULL, on_complete_get_result, &result,
+	                       "even", TRUE,
+	                       "string", "twelve",
+	                       "number", 12,
+	                       NULL);
+	g_assert_null (result);
+	egg_test_wait ();
+	ret = secret_password_store_finish (result, &error);
+	g_assert_no_error (error);
+	g_assert_true (ret);
+	g_clear_object (&result);
+
+	/* Check collection state */
+	g_assert_false (secret_collection_get_locked (collection));
+
+
+	password = secret_password_lookup_nonpageable_sync (&MOCK_SCHEMA, NULL, &error,
+	                                                    "string", "twelve",
+	                                                    NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (password, ==, "the password");
+
+	secret_password_free (password);
+	g_object_unref (collection);
+	g_object_unref (service);
+}
+
+static void
+test_delete_sync (Test *test,
+                  gconstpointer used)
+{
+	GError *error = NULL;
+	gboolean ret;
+
+	ret = secret_password_clear_sync (&MOCK_SCHEMA, NULL, &error,
+	                                  "even", FALSE,
+	                                  "string", "one",
+	                                  "number", 1,
+	                                  NULL);
+
+	g_assert_no_error (error);
+	g_assert_true (ret);
+}
+
+static void
+test_delete_async (Test *test,
+                   gconstpointer used)
+{
+	GError *error = NULL;
+	GAsyncResult *result = NULL;
+	gboolean ret;
+
+	secret_password_clear (&MOCK_SCHEMA, NULL,
+	                       on_complete_get_result, &result,
+	                       "even", FALSE,
+	                       "string", "one",
+	                       "number", 1,
+	                       NULL);
+
+	g_assert_null (result);
+
+	egg_test_wait ();
+
+	ret = secret_password_clear_finish (result, &error);
+	g_assert_no_error (error);
+	g_assert_true (ret);
+
+	g_object_unref (result);
+}
+
+static void
+test_clear_no_name (Test *test,
+                    gconstpointer used)
+{
+	const gchar *paths[] = { "/org/freedesktop/secrets/collection/german", NULL };
+	SecretService *service;
+	GError *error = NULL;
+	gboolean ret;
+
+	/* Shouldn't match anything, because no item with 5 in mock schema */
+	ret = secret_password_clear_sync (&MOCK_SCHEMA, NULL, &error,
+										"number", 5,
+										NULL);
+	g_assert_no_error (error);
+	g_assert_false (ret);
+
+
+	ret = secret_password_clear_sync (&MOCK_SCHEMA, NULL, &error,
+										"number", 3,
+										NULL);
+
+	g_assert_no_error (error);
+	g_assert_true (ret);
+}
+
+static void
+free_attributes (gpointer data,
+                 gpointer user_data)
+{
+        g_object_unref ((GObject *)data);
+}
+
+static void
+test_search_sync (Test *test,
+                  gconstpointer used)
+{
+        GList *items;
+        GError *error = NULL;
+
+        items = secret_password_search_sync (&MOCK_SCHEMA, SECRET_SEARCH_ALL,
+					     NULL, &error,
+                                             "even", FALSE,
+                                             "string", "one",
+                                             "number", 1,
+                                             NULL);
+
+        g_assert_no_error (error);
+        g_assert_cmpint (g_list_length (items), ==, 1);
+
+        g_list_foreach (items, free_attributes, NULL);
+        g_list_free (items);
+}
+
+static void
+test_search_async (Test *test,
+                   gconstpointer used)
+{
+        GAsyncResult *result = NULL;
+        GError *error = NULL;
+        GList *items;
+
+        secret_password_search (&MOCK_SCHEMA, SECRET_SEARCH_ALL,
+				NULL, on_complete_get_result, &result,
+                                "even", FALSE,
+                                "string", "one",
+                                "number", 1,
+                                NULL);
+        g_assert (result == NULL);
+
+        egg_test_wait ();
+
+        items = secret_password_search_finish (result, &error);
+        g_assert_no_error (error);
+        g_object_unref (result);
+
+        g_assert_cmpint (g_list_length (items), ==, 1);
+
+        g_list_foreach (items, free_attributes, NULL);
+        g_list_free (items);
+}
+
+static void
+test_search_no_name (Test *test,
+                     gconstpointer used)
+{
+        GError *error = NULL;
+        GList *items;
+
+        /* should return null, because nothing with mock schema and 5 */
+        items = secret_password_search_sync (&MOCK_SCHEMA, SECRET_SEARCH_ALL,
+					     NULL, &error,
+                                             "number", 5,
+                                             NULL);
+        g_assert_no_error (error);
+        g_assert (items == NULL);
+
+        /* should return an item, because we have a prime schema with 5, and flags not to match name */
+        items = secret_password_search_sync (&NO_NAME_SCHEMA, SECRET_SEARCH_ALL,
+					     NULL, &error,
+                                             "number", 5,
+                                             NULL);
+
+        g_assert_no_error (error);
+        g_assert_cmpint (g_list_length (items), ==, 1);
+
+        g_list_foreach (items, free_attributes, NULL);
+        g_list_free (items);
+}
+
+static void
+test_binary_sync (Test *test,
+                  gconstpointer used)
+{
+	const gchar *collection_path = "/org/freedesktop/secrets/collection/english";
+	GError *error = NULL;
+	SecretValue *value;
+	gboolean ret;
+
+	value = secret_value_new ("the password", -1, "text/plain");
+	ret = secret_password_store_binary_sync (&MOCK_SCHEMA, collection_path,
+						 "Label here", value, NULL, &error,
+						 "even", TRUE,
+						 "string", "twelve",
+						 "number", 12,
+						 NULL);
+
+	g_assert_no_error (error);
+	g_assert_true (ret);
+	secret_value_unref (value);
+
+	value = secret_password_lookup_binary_sync (&MOCK_SCHEMA, NULL, &error,
+						    "string", "twelve",
+						    NULL);
+
+	g_assert_no_error (error);
+	g_assert_cmpstr (secret_value_get_text (value), ==, "the password");
+
+	secret_value_unref (value);
+}
+
+static void
+test_binary_async (Test *test,
+                  gconstpointer used)
+{
+	const gchar *collection_path = "/org/freedesktop/secrets/collection/english";
+	GAsyncResult *result = NULL;
+	GError *error = NULL;
+	SecretValue *value;
+	gboolean ret;
+
+	value = secret_value_new ("the password", -1, "text/plain");
+	secret_password_store_binary (&MOCK_SCHEMA, collection_path, "Label here",
+				      value, NULL, on_complete_get_result, &result,
+				      "even", TRUE,
+				      "string", "twelve",
+				      "number", 12,
+				      NULL);
+	g_assert_null (result);
+	secret_value_unref (value);
+
+	egg_test_wait ();
+
+	ret = secret_password_store_finish (result, &error);
+	g_assert_no_error (error);
+	g_assert_true (ret);
+	g_object_unref (result);
+
+	value = secret_password_lookup_binary_sync (&MOCK_SCHEMA, NULL, &error,
+						    "string", "twelve",
+						    NULL);
+
+	g_assert_no_error (error);
+	g_assert_nonnull (value);
+
+	g_assert_cmpstr (secret_value_get_text (value), ==, "the password");
+
+	secret_value_unref (value);
+}
+
+static void
+test_password_free_null (void)
+{
+	secret_password_free (NULL);
+}
+
+int
+main (int argc, char **argv)
+{
+	g_test_init (&argc, &argv, NULL);
+	g_set_prgname ("test-password");
+
+	g_test_add ("/password/lookup-sync", Test, "mock-service-normal.py", setup, test_lookup_sync, teardown);
+	// g_test_add ("/password/lookup-async", Test, "mock-service-normal.py", setup, test_lookup_async, teardown);
+	g_test_add ("/password/lookup-no-name", Test, "mock-service-normal.py", setup, test_lookup_no_name, teardown);
+
+	g_test_add ("/password/store-sync", Test, "mock-service-normal.py", setup, test_store_sync, teardown);
+	// g_test_add ("/password/store-async", Test, "mock-service-normal.py", setup, test_store_async, teardown);
+	// g_test_add ("/password/store-unlock", Test, "mock-service-normal.py", setup, test_store_unlock, teardown);
+
+	g_test_add ("/password/delete-sync", Test, "mock-service-delete.py", setup, test_delete_sync, teardown);
+	// g_test_add ("/password/delete-async", Test, "mock-service-delete.py", setup, test_delete_async, teardown);
+	g_test_add ("/password/clear-no-name", Test, "mock-service-delete.py", setup, test_clear_no_name, teardown);
+
+	// g_test_add ("/password/search-sync", Test, "mock-service-normal.py", setup, test_search_sync, teardown);
+	// g_test_add ("/password/search-async", Test, "mock-service-normal.py", setup, test_search_async, teardown);
+	// g_test_add ("/password/search-no-name", Test, "mock-service-normal.py", setup, test_search_no_name, teardown);
+
+	g_test_add ("/password/binary-sync", Test, "mock-service-normal.py", setup, test_binary_sync, teardown);
+	// g_test_add ("/password/binary-async", Test, "mock-service-normal.py", setup, test_binary_async, teardown);
+
+	g_test_add_func ("/password/free-null", test_password_free_null);
+
+	return egg_tests_run_with_loop ();
+}
diff --git a/meson.build b/meson.build
index d3ca2ce..c665559 100644
--- a/meson.build
+++ b/meson.build
@@ -1,4 +1,4 @@
-project('libsecret', 'c',
+project('libsecret', ['c', 'cpp'],
   version: '0.21.3',
   license: 'GPL2+',
   meson_version: '>= 0.50',
diff --git a/meson_options.txt b/meson_options.txt
index 936eff8..93459c3 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -8,3 +8,4 @@ option('bashcompdir', type: 'string', value: '', description: 'Override default
 option('bash_completion', type: 'feature', value: 'auto', description: 'Install bash completion files')
 option('tpm2', type: 'boolean', value: false, description: 'With TPM2 Software Stack')
 option('pam', type: 'boolean', value: false, description: 'Build PAM module')
+option('is_ohos', type: 'boolean', value: false, description: 'using at ohos platform')
diff --git a/tool/secret-tool.c b/tool/secret-tool.c
index c72e403..8ff6104 100644
--- a/tool/secret-tool.c
+++ b/tool/secret-tool.c
@@ -23,6 +23,7 @@
 
 #include <glib/gi18n.h>
 
+#include <stdio.h>
 #include <errno.h>
 #include <locale.h>
 #include <limits.h>
@@ -281,12 +282,24 @@ read_password_stdin (void)
 	}
 }
 
+#define MAX_PASSWORD_LENGTH 1024
+
 static SecretValue *
 read_password_tty (void)
 {
 	gchar *password;
+#ifdef __OHOS__
+	static char s_password[MAX_PASSWORD_LENGTH];
+    printf("Password: ");
+
+    fgets(s_password, MAX_PASSWORD_LENGTH, stdin);
+    s_password[strcspn(s_password, "\n")] = '\0';
 
+    password = g_strdup(s_password);
+	memset(s_password, 0, sizeof s_password);
+#else
 	password = getpass ("Password: ");
+#endif
 	return secret_value_new_full (password, -1, "text/plain",
 	                              (GDestroyNotify)secret_password_wipe);
 }
-- 
2.36.1.windows.1

